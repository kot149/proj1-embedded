/*
 Blinky
 @omzn  2020/10/20
 */
#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include "inc/hw_i2c.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_qei.h"
#include "inc/hw_timer.h"
#include "driverlib/rom.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/pwm.h"
#include "driverlib/timer.h"
#include "driverlib/qei.h"
#include "utils/uartstdio.h"
#include "utils/uartstdio.c" //strong-arm method

#include "periphConf.h" //generated by PinMux

#include "my_util.h"

uint32_t base_led_color;
uint32_t led_color = LED_ALL;

//*****************************************************************************
//
// This function sets up UART0 to be used for a console to display information
// as the example is running.
//
//*****************************************************************************
void initConsole(void) {
	// Enable GPIO port A which is used for UART0 pins.
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
	// Configure the pin muxing for UART0 functions on port A0 and A1.
	// This step is not necessary if your part does not support pin muxing.
	GPIOPinConfigure(GPIO_PA0_U0RX);
	GPIOPinConfigure(GPIO_PA1_U0TX);
	// Enable UART0 so that we can configure the clock.
	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
	// Use the internal 16MHz oscillator as the UART clock source.
	UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
	// Select the alternate (UART) function for these pins.
	GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
	// Initialize the UART for console I/O.
	UARTStdioConfig(0, 9600, 16000000);
}

void initInterruptPins(void) {
	// You can write your own code here.
	//GPIOIntDisable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
	GPIOIntClear(GPIO_PORTF_BASE, INT_ALL_BUTTONS);

	GPIOIntRegister(GPIO_PORTF_BASE, SW1PinIntHandler);

	GPIOIntTypeSet(GPIO_PORTF_BASE, INT_ALL_BUTTONS, GPIO_FALLING_EDGE);

	//GPIOIntEnable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
}

void initPWMLEDCtl(void) {
	SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

	GPIOPinConfigure(GPIO_PF2_M1PWM6);
	GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);

	GPIOPinConfigure(GPIO_PF3_M1PWM7);
	GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);

	GPIOPinConfigure(GPIO_PF1_M1PWM5);
	GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_1);


	PWMGenConfigure(PWM1_BASE, PWM_GEN_2,
	PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
	PWMGenConfigure(PWM1_BASE, PWM_GEN_3,
	PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);

	PWMGenPeriodSet(PWM1_BASE, PWM_GEN_2, 10000); //PWMClock=1000000
	PWMGenPeriodSet(PWM1_BASE, PWM_GEN_3, 10000);

	//PWMPulseWidthSet(PWM1_BASE, PWM_OUT_5, 500);
	//PWMPulseWidthSet(PWM1_BASE, PWM_OUT_6, 500);
	//PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, 500);

	PWMOutputState(PWM1_BASE, PWM_OUT_5_BIT, true);
	PWMOutputState(PWM1_BASE, PWM_OUT_6_BIT, true);
	PWMOutputState(PWM1_BASE, PWM_OUT_7_BIT, true);

	PWMGenEnable(PWM1_BASE, PWM_GEN_2);
	PWMGenEnable(PWM1_BASE, PWM_GEN_3);

}

void setPulseWidth(int32_t r, int32_t g, int32_t b){
    PWMPulseWidthSet(PWM1_BASE, PWM_OUT_5, r);
    PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, g);
    PWMPulseWidthSet(PWM1_BASE, PWM_OUT_6, b);
}

//*****************************************************************************
// Event handers
//*****************************************************************************

void SysTickIntHandler(void) {
	static uint32_t tick_count = 0;
	static uint8_t flag = 1;
	int r = 20;

	if (tick_count >= 1000 / r) flag = 0;
	if (tick_count == 0) flag = 1;


	switch(base_led_color){
	case LED_BLUE:
		setPulseWidth(tick_count * r, 0, 0);
		break;
	case LED_RED:
		setPulseWidth(0, 0, tick_count * r);
		break;
	case LED_GREEN:
		setPulseWidth(0, tick_count * r, 0);
		break;
	case LED_WHITE:
		setPulseWidth(tick_count * r / 3, tick_count * r / 3, tick_count * r / 3);
		break;
	default:
		base_led_color = LED_BLUE;
		setPulseWidth(tick_count * r, 0, 0);
		break;
	}

	if(flag) tick_count++;
	else tick_count--;
}

void SW1PinIntHandler(void) {
	GPIOIntDisable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
	GPIOIntClear(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
	GPIOPinWrite(GPIO_PORTF_BASE, base_led_color, 0); // turn off all LEDs

	switch (base_led_color) {
	case LED_BLUE:
		base_led_color = LED_RED;
		break;
	case LED_RED:
		base_led_color = LED_GREEN;
		break;
	case LED_GREEN:
		base_led_color = LED_WHITE;
		break;
	case LED_WHITE:
		base_led_color = LED_BLUE;
		break;
	default:
		base_led_color = LED_BLUE;
		break;
	}

	GPIOPinWrite(GPIO_PORTF_BASE, base_led_color, led_color);

	GPIOIntEnable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
}

int main(void) {
	// Set the clocking to run directly from the crystal.
	ROM_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
	SYSCTL_XTAL_16MHZ);
	// Set up ports hardware (see periphConf.c)
	PortFunctionInit();

	// Set up interrupts (you can specify GPIO interrupt initialization here)
	initInterruptPins();

	// Initialize console
	initConsole();
	UARTprintf("Hello, world!\n");

	led_color = LED_ALL;
	base_led_color = LED_BLUE;
	GPIOIntEnable(GPIO_PORTF_BASE,INT_ALL_BUTTONS);
	//GPIOPinWrite(GPIO_PORTF_BASE,base_led_color,led_color);

	initPWMLEDCtl();

	SysTickPeriodSet(SysCtlClockGet() / SYSTICKS_PER_SEC);
	SysTickEnable();
	SysTickIntRegister(SysTickIntHandler);
	SysTickIntEnable();

	while (1);
}
