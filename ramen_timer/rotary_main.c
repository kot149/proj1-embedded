/*
  Rotary Encoder
    @omzn  2020/10/20
*/

#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include "inc/hw_i2c.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_qei.h"
#include "inc/hw_timer.h"
#include "driverlib/rom.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/pwm.h"
#include "driverlib/timer.h"

#include "driverlib/qei.h"
#include "utils/uartstdio.h"
#include "utils/uartstdio.c" //strong-arm method

#include "periphConf.h" //generated by PinMux

#include "my_util.h"
#include "my_i2c.h"

#include "buzzer.h"
#include "lcd_SB1602.h"
#include "colorSensor_TCS3472.h"
#include "rotaryEncoder.h"

int32_t tick_count = 0;

int32_t time = 30;
bool timerEnabled = false;

//uint32_t p; // QEI Position
//int32_t  d; // QEI Direction

uint32_t led_color = LED_YELLOW;

void writeTimeLCD(int32_t t){
    setAddressLCD(5, 0);
    writeTextLCD(itoa(t, 3), 3);
}

//*****************************************************************************
//
// This function sets up UART0 to be used for a console to display information
// as the example is running.
//
//*****************************************************************************
void initConsole(void) {
  // Enable GPIO port A which is used for UART0 pins.
  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
  // Configure the pin muxing for UART0 functions on port A0 and A1.
  // This step is not necessary if your part does not support pin muxing.
  GPIOPinConfigure(GPIO_PA0_U0RX);
  GPIOPinConfigure(GPIO_PA1_U0TX);
  // Enable UART0 so that we can configure the clock.
  SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
  // Use the internal 16MHz oscillator as the UART clock source.
  UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
  // Select the alternate (UART) function for these pins.
  GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
  // Initialize the UART for console I/O.
  UARTStdioConfig(0, 9600, 16000000);
}

void initInterruptPins(void) {
    // Register the port-level interrupt handler. This handler is the first
    // level interrupt handler for all the pin interrupts.
    //GPIOIntRegister(GPIO_PORTB_BASE, SensorIntHandler);
    // Make pins 0 low level triggered interrupts.
    //GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_0, GPIO_LOW_LEVEL);
    // PB0 pull-up
    //GPIOPadConfigSet(GPIO_PORTB_BASE, GPIO_PIN_0,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);

    // Set SW1 as an interrupt
    GPIOIntRegister(GPIO_PORTF_BASE, SW1PinIntHandler);
    // Make pins 4 falling-edge triggered interrupts.
    GPIOIntTypeSet(GPIO_PORTF_BASE, GPIO_INT_PIN_4, GPIO_FALLING_EDGE);
    // PF4 pull-up
    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);

    // Watch QEI as an interrupt
    GPIOIntRegister(GPIO_PORTD_BASE, REPinIntHandler);
    // Make pins PD6 falling-edge triggered interrupts.
    GPIOIntTypeSet(GPIO_PORTD_BASE, GPIO_INT_PIN_6, GPIO_FALLING_EDGE);
    // (PD6 is physically pulled-up)
}

//*****************************************************************************
// Event handers
//*****************************************************************************

void SysTickIntHandler(void) {
	if(!timerEnabled) return;
	tick_count++;

	if(tick_count % SYSTICKS_PER_SEC == 0){// Count down timer
	    time--;
	    writeTimeLCD(time);
	    if(time == 0){
	        toneBuzzer(O4C);
	        timerEnabled = false;

	        // Set LED Red
	        GPIOPinWrite(GPIO_PORTF_BASE, LED_ALL, 0);
	        GPIOPinWrite(GPIO_PORTF_BASE, LED_ALL, LED_RED);
	    } else {
	        // Turn on LED
	        GPIOPinWrite(GPIO_PORTF_BASE, led_color, led_color);
	    }
	} else if(tick_count % (SYSTICKS_PER_SEC / 2) == 0){
	    // Turn off LED
	    GPIOPinWrite(GPIO_PORTF_BASE, LED_ALL, 0);
	}
}

void SW1PinIntHandler(void) {
    GPIOIntDisable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
    GPIOIntClear(GPIO_PORTF_BASE, INT_ALL_BUTTONS);

    if(timerEnabled){// Turn off timer
        timerEnabled = false;
        // Turn off LED
        GPIOPinWrite(GPIO_PORTF_BASE, LED_ALL, 0);
    } else if(time > 0){// Turn on timer
        tick_count = 0;
        timerEnabled = true;
    }

    GPIOIntEnable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
}

void REPinIntHandler(void) {
    GPIOIntDisable(GPIO_PORTD_BASE, GPIO_INT_PIN_6);
    GPIOIntClear(GPIO_PORTD_BASE, GPIO_INT_PIN_6);

    if(!timerEnabled){
        // Increase or decrease timer count
        time += 5 * QEIDirectionGet(QEI0_BASE);
        if(time < 0) time = 0;
        else if(time > 600) time = 600;

        writeTimeLCD(time);

        // Turn off LED
        GPIOPinWrite(GPIO_PORTF_BASE, LED_ALL, 0);
        // Turn off Buzzer
        restBuzzer();
    }

    GPIOIntEnable(GPIO_PORTD_BASE, GPIO_INT_PIN_6);
}

int main(void) {
  // Set the clocking to run directly from the crystal.
  ROM_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
		     SYSCTL_XTAL_16MHZ);
  // Set up ports hardware (see periphConf.c)
  PortFunctionInit();

  // Set up interrupts (you can specify GPIO interrupt initialization here)
  initInterruptPins();

  // Initialize console
  initConsole();
  //UARTprintf("Rotary encoder example\n");

  // Init Rotary Encoder
  initRotaryEncoder();

  // Init I2C
  initI2C(I2C3_BASE);
  // Init LCD
  initLCD();

  writeTimeLCD(time);

  // Init Buzzer
  initBuzzer();

  // Set SysTick Interrupt
  SysTickPeriodSet(SysCtlClockGet() / SYSTICKS_PER_SEC);
  SysTickEnable();
  SysTickIntRegister(SysTickIntHandler);
  SysTickIntEnable();

  // Enable Interrupt
  GPIOIntEnable(GPIO_PORTD_BASE, GPIO_INT_PIN_6);
  GPIOIntEnable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);

  while(1);
}

