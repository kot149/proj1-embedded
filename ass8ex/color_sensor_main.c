/*
  Color sensor
    @omzn  2020/10/20
*/

#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h"
#include "driverlib/uart.h"
#include "inc/hw_i2c.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_qei.h"
#include "inc/hw_timer.h"
#include "inc/hw_types.h"
#include "driverlib/qei.h"
#include "utils/uartstdio.c" //strong-arm method
#include "utils/uartstdio.h"

#include "periphConf.h" //generated by PinMux

#include "my_i2c.h"
#include "my_util.h"

#include "buzzer.h"
#include "colorSensor_TCS3472.h"
#include "lcd_SB1602.h"
#include "rotaryEncoder.h"

uint8_t colorSensorAdjustState = 0;

#define COLOR_NONE    0
#define COLOR_RED     1
#define COLOR_GREEN   2
#define COLOR_BLUE    3
#define COLOR_YELLOW  4
#define COLOR_NUM     4

#define MAX_COLOR_NAME_LENGTH 6
uint8_t color_name_str[COLOR_NUM+1][MAX_COLOR_NAME_LENGTH+1] = {"None", "Red", "Green", "Blue", "Yellow"};
uint8_t color_count[COLOR_NUM+1] = {0, 0, 0, 0, 0}; // Array to store the number of detection of each colors

uint32_t led_color[] = {LED_WHITE, LED_RED, LED_GREEN, LED_BLUE, LED_YELLOW};

// Array to store the value G/R and B/R of each color
float color_ratio[COLOR_NUM][2];

int8_t last_color = COLOR_NONE;
int8_t color_wanted = COLOR_RED;

bool ringing = false;
uint8_t systick_per_sec = 32;

// Threshold of color sensor interrupt
uint16_t low_th = 0, high_th;

uint32_t melody[] = {O4D, O4C, O4D, O4E, O4G, O4E, O4D, RR,
                    O4E, O4G, O4A, O4G, O4A, RR, O5D, O4B, O4A, O4G};
uint32_t melody_length[] = {1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 2, 2, 1, 1, 1, 1, 1};
#define MELODY_MAX 18

void clearTextLCD(uint8_t mode){
    if(mode == 1 || mode == 3){
        setAddressLCD(0, 0);
        writeTextLCD("                ", 16);
    }
    if(mode == 2 || mode == 3){
        setAddressLCD(0, 1);
        writeTextLCD("                ", 16);
    }
}

void LCDprint(uint8_t *str){
    #define MAX_LENGTH 16
    uint8_t tmp[MAX_LENGTH];
    uint8_t i;
    uint8_t flag = 0;

    setAddressLCD(0, 0);
    for(i = 0; i < MAX_LENGTH; i++){
        if(str[i] == '\0'){
            flag = 1;
            while(i < MAX_LENGTH) tmp[i++] = ' ';
            break;
        }
        tmp[i] = str[i];
    }
    writeTextLCD(tmp, 16);

    setAddressLCD(0, 1);
    for(i = MAX_LENGTH; i < MAX_LENGTH*2; i++){
        if(str[i] == '\0' || flag){
            while(i < MAX_LENGTH*2) tmp[i++ - MAX_LENGTH] = ' ';
            break;
        }
        tmp[i - MAX_LENGTH] = str[i];
    }
    writeTextLCD(tmp, 16);
}

float average(uint16_t *data, uint8_t num){
    float sum = 0;
    uint8_t i;
    for(i = 0; i < num; i++) sum += data[i];

    return sum / num;
}

float variance(uint16_t *data, uint8_t num){
    float sum = 0;
    uint8_t i;
    for(i = 0; i < num; i++) sum += pow(data[i], 2);

    return sum / num - pow(average(data, num), 2);
}

void showColorCount(){
    setAddressLCD(9, 0);

    writeTextLCD("R", 1);
    writeTextLCD(itoa(color_count[COLOR_RED], 2), 2);

    writeTextLCD(" Y", 2);
    writeTextLCD(itoa(color_count[COLOR_YELLOW], 2), 2);

    setAddressLCD(9, 1);

    writeTextLCD("G", 1);
    writeTextLCD(itoa(color_count[COLOR_GREEN], 2), 2);
    writeTextLCD(" B", 2);
    writeTextLCD(itoa(color_count[COLOR_BLUE], 2), 2);
}

void setColorRatio(uint8_t color){
    uint16_t data[3][10];
    float ave_r;
    uint8_t i = 0;

    clearTextLCD(3);
    setAddressLCD(0, 0);
//    UARTprintf(color_name_str[color]);
    UARTprintf("\n");
    writeTextLCD("Reading data ", 13);
    for(i = 0; i < 10; i++){
        setAddressLCD(13, 0);
        writeTextLCD(itoa(i+1, 2), 2);

        data[0][i] = read16ColorSensor(RDATAL_REG);
        data[1][i] = read16ColorSensor(GDATAL_REG);
        data[2][i] = read16ColorSensor(BDATAL_REG);
        delay_ms(154);

//        UARTprintf(itoh(data[0][i], 4), 4);
//        UARTprintf("\t");
//        UARTprintf(itoh(data[1][i], 4), 4);
//        UARTprintf("\t");
//        UARTprintf(itoh(data[2][i], 4), 4);
//        UARTprintf("\n");
    }
    ave_r = average(data[0], 10);

    color_ratio[color-1][0] = (float)average(data[1], 10) / ave_r;
    color_ratio[color-1][1] = (float)average(data[2], 10) / ave_r;
}

int8_t detectColor(uint16_t r, uint16_t g, uint16_t b){
    #define INMARGIN(a, c, m) a >= c - m && a <= c + m
    float gr, br;
    gr = (float)g / r;
    br = (float)b / r;

    float margin_rate = 0.2;
    if(INMARGIN(gr, color_ratio[COLOR_RED-1][0], color_ratio[COLOR_RED-1][0] * margin_rate)
            && INMARGIN(br, color_ratio[COLOR_RED-1][1], color_ratio[COLOR_RED-1][1] * margin_rate))
        return COLOR_RED;
    else if(INMARGIN(gr, color_ratio[COLOR_GREEN-1][0], color_ratio[COLOR_GREEN-1][0] * margin_rate)
            && INMARGIN(br, color_ratio[COLOR_GREEN-1][1], color_ratio[COLOR_GREEN-1][1] * margin_rate))
        return COLOR_GREEN;
    else if(INMARGIN(gr, color_ratio[COLOR_BLUE-1][0], color_ratio[COLOR_BLUE-1][0] * margin_rate)
            && INMARGIN(br, color_ratio[COLOR_BLUE-1][1], color_ratio[COLOR_BLUE-1][1] * margin_rate))
        return COLOR_BLUE;
    else if(INMARGIN(gr, color_ratio[COLOR_YELLOW-1][0], color_ratio[COLOR_YELLOW-1][0] * margin_rate)
            && INMARGIN(br, color_ratio[COLOR_YELLOW-1][1], color_ratio[COLOR_YELLOW-1][1] * margin_rate))
        return COLOR_YELLOW;
    return COLOR_NONE;
}

//*****************************************************************************
//
// This function sets up UART0 to be used for a console to display information
// as the example is running.
//
//*****************************************************************************
void initConsole(void) {
  // Enable GPIO port A which is used for UART0 pins.
  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
  // Configure the pin muxing for UART0 functions on port A0 and A1.
  // This step is not necessary if your part does not support pin muxing.
  GPIOPinConfigure(GPIO_PA0_U0RX);
  GPIOPinConfigure(GPIO_PA1_U0TX);
  // Enable UART0 so that we can configure the clock.
  SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
  // Use the internal 16MHz oscillator as the UART clock source.
  UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
  // Select the alternate (UART) function for these pins.
  GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
  // Initialize the UART for console I/O.
  UARTStdioConfig(0, 9600, 16000000);
}

void initInterruptPins(void) {
    // Init SW1 Interrupt
    GPIOIntClear(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
    GPIOIntRegister(GPIO_PORTF_BASE, SW1PinIntHandler);
    GPIOIntTypeSet(GPIO_PORTF_BASE, INT_ALL_BUTTONS, GPIO_FALLING_EDGE);

    // Init Interrupt for Color Sensor
    GPIOIntRegister(GPIO_PORTB_BASE,ColorSensorIntHandler);
    // Make pins 0 low level triggered interrupts.
    GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_INT_PIN_0, GPIO_LOW_LEVEL);
    GPIOPadConfigSet(GPIO_PORTB_BASE, GPIO_INT_PIN_0,
    GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);

    // Init Interrupt for Rotary Encoder
    // Watch QEI as an interrupt
    GPIOIntRegister(GPIO_PORTD_BASE, REPinIntHandler);
    // Make pins PD6 falling-edge triggered interrupts.
    GPIOIntTypeSet(GPIO_PORTD_BASE, GPIO_INT_PIN_6, GPIO_FALLING_EDGE);
}

void initTimerInterrupt(){
//    TimerIntRegister(WTIMER5_BASE, TIMER_B, TimerIntHandler);
//    TimerLoadSet64(WTIMER5_BASE, 10);
//    TimerIntEnable(WTIMER5_BASE, TIMER_TIMB_TIMEOUT);
//    TimerEnable(WTIMER5_BASE, TIMER_B);
//    IntEnable(INT_WTIMER5B);
}

//*****************************************************************************
// Event handers
//*****************************************************************************

void SysTickIntHandler(void) {
    static uint32_t led_base = LED_ALL;
    static uint32_t tick_count = 0;
    static uint32_t buzzer_count = 0;

    // Blink LED
    if(tick_count >= systick_per_sec / 2){
        led_base = ~led_base;
        GPIOPinWrite(GPIO_PORTF_BASE, LED_ALL, 0);
        GPIOPinWrite(GPIO_PORTF_BASE, led_color[last_color], led_base);
        tick_count = 0;
    }
    tick_count++;

    // Stop buzzer
    static int8_t index = -1;
    if(ringing){
        buzzer_count++;
        if(buzzer_count >= systick_per_sec / melody_length[index]){
            index++;
            restBuzzer();
            buzzer_count = 0;
            toneBuzzer(melody[index]);
            if(index == MELODY_MAX){
                restBuzzer();
                ringing = false;
                buzzer_count = 0;
                index = 0;
            }
        }
    }
}

void TimerIntHandler(void){
    LCDprint("Timer Intterupt");
}

void SW1PinIntHandler(void) {
    GPIOIntDisable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
    GPIOIntClear(GPIO_PORTF_BASE, INT_ALL_BUTTONS);

    uint8_t i = 0;
    uint16_t data[10];

    switch(colorSensorAdjustState){
    case 0:
        ringing = true;
        LCDprint("Push SW1 to determine black.");
        last_color = COLOR_NONE;
        colorSensorAdjustState = 1;
        break;
    case 1: // Determine Black
        clearTextLCD(3);
        setAddressLCD(0, 0);
        writeTextLCD("Reading data ", 13);
        for(i = 0; i < 10; i++){
            setAddressLCD(13, 0);
            writeTextLCD(itoa(i+1, 2), 2);

            data[i] = read16ColorSensor(CDATAL_REG);
            delay_ms(154);
        }

        high_th = (uint16_t)(average(data, 10) + sqrt(variance(data, 10)) * 5);
        setIntThresholdColorSensor(low_th, high_th);
        UARTprintf("%d\n", (int)sqrt(variance(data, 10)));

        LCDprint("Push SW1 to determine red.");
        last_color = COLOR_RED;

        colorSensorAdjustState = 2;
        break;
    case 2: // Determine Red
        setColorRatio(COLOR_RED);

        LCDprint("Push SW1 to determine green.");
        last_color = COLOR_GREEN;

        colorSensorAdjustState = 3;
        break;
    case 3: // Determine Green
        setColorRatio(COLOR_GREEN);

        LCDprint("Push SW1 to determine blue.");
        last_color = COLOR_BLUE;

        colorSensorAdjustState = 4;
        break;
    case 4: // Determine Blue
        setColorRatio(COLOR_BLUE);

        LCDprint("Push SW1 to determine yellow.");
        last_color = COLOR_YELLOW;

        colorSensorAdjustState = 5;
        break;
    case 5: // Determine Yellow
        setColorRatio(COLOR_YELLOW);

        LCDprint("Done. Push SW1 to continue.");
        last_color = COLOR_NONE;

        colorSensorAdjustState = 6;

        break;
    case 6:
        // Initialize LCD
        clearTextLCD(3);
        setAddressLCD(0, 0);
        writeTextLCD("Red", 3);
        setAddressLCD(0, 1);
        writeTextLCD("None", 4);
        showColorCount();

        // Enable Color Sensor Interrupt
        GPIOIntEnable(GPIO_PORTB_BASE, GPIO_INT_PIN_0);
        // Enable Rotary Encoder Interrupt
        GPIOIntEnable(GPIO_PORTD_BASE, GPIO_INT_PIN_6);
    case 7: // Reset color detection count
        color_count[COLOR_RED] = color_count[COLOR_GREEN] = color_count[COLOR_YELLOW] = color_count[COLOR_BLUE] = 0;
        showColorCount();

        break;
    }

    GPIOIntEnable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);
}

void ColorSensorIntHandler(void){
    GPIOIntDisable(GPIO_PORTB_BASE, GPIO_INT_PIN_0);
    GPIOIntClear(GPIO_PORTB_BASE, GPIO_INT_PIN_0);
    clearIntColorSensor();

    int8_t color_detected = detectColor(read16ColorSensor(RDATAL_REG), read16ColorSensor(GDATAL_REG), read16ColorSensor(BDATAL_REG));

    if(color_detected != COLOR_NONE){
        if(last_color != color_detected){

            color_count[color_detected]++;
            showColorCount();

            //if(color_detected == color_wanted) toneBuzzer(O4A);
            ringing = true;
        }
        setIntThresholdColorSensor(low_th, low_th);
    } else {
        setIntThresholdColorSensor(low_th, high_th);
    }

    setAddressLCD(0, 1);
    uint8_t i;
    for(i = 0; i < MAX_COLOR_NAME_LENGTH; i++) writeTextLCD(" ", 1);
    setAddressLCD(0, 1);
    writeTextLCD(color_name_str[color_detected], 6);

    last_color = color_detected;

    GPIOIntEnable(GPIO_PORTB_BASE, INT_ALL_BUTTONS);
}

void REPinIntHandler(void) {
    GPIOIntDisable(GPIO_PORTD_BASE, GPIO_INT_PIN_6);
    GPIOIntClear(GPIO_PORTD_BASE, GPIO_INT_PIN_6);

    color_wanted += QEIDirectionGet(QEI0_BASE);
    if(color_wanted == 0) color_wanted = COLOR_NUM;
    else if(color_wanted == COLOR_NUM+1) color_wanted = 1;

    setAddressLCD(0, 0);
    uint8_t i;
    for(i = 0; i < MAX_COLOR_NAME_LENGTH; i++) writeTextLCD(" ", 1);
    setAddressLCD(0, 0);
    writeTextLCD(color_name_str[color_wanted], 6);

    GPIOIntEnable(GPIO_PORTD_BASE, GPIO_INT_PIN_6);
}

int main(void) {
    // Set the clocking to run directly from the crystal.
    ROM_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
                       SYSCTL_XTAL_16MHZ);
    // Set up ports hardware (see periphConf.c)
    PortFunctionInit();

    // Set up interrupts (you can specify GPIO interrupt initialization here)
    initInterruptPins();

    // Initialize console
    initConsole();
    UARTprintf("Color Sensor\n");

    // Initialize buzzer
    initBuzzer();

    // Initialize two I2C Masters
    initI2C(I2C3_BASE);
    // Initialize LCD module
    initLCD();

    // Initialize Rotary Encoder
    initRotaryEncoder();

    // Initialize color sensor module
    initColorSensor(INTEGRATIONTIME_154MS, GAIN_16X);
    clearIntColorSensor();

    GPIOIntEnable(GPIO_PORTF_BASE, INT_ALL_BUTTONS);

    LCDprint("Push SW1 to start adjustment...");

    // Init SysTick Interrupt
    SysTickPeriodSet(SysCtlClockGet() / systick_per_sec);
    SysTickEnable();
    SysTickIntRegister(SysTickIntHandler);
    SysTickIntEnable();

     // Init Timer Interrupt
     //toneBuzzer(O4C);
     TimerIntRegister(WTIMER5_BASE, TIMER_B, TimerIntHandler);
     TimerLoadSet64(WTIMER5_BASE, 10);
     TimerIntEnable(WTIMER5_BASE, TIMER_TIMB_TIMEOUT);
     TimerEnable(WTIMER5_BASE, TIMER_B);
     IntEnable(INT_WTIMER5B);

    while(1);
}
